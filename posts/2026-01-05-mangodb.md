---
layout: post
title: "MangoDB: When Files Are Good Enough"
date: 2026-01-05
description: "SQLite for MongoDB. Same API, zero setup."
---

*SQLite for MongoDB. Same API, zero setup.*

I was coding on my phone (slightly ridiculous, I know, but I like it) and wanted to prototype something with MongoDB. Setting up MongoDB on a phone? Not happening. Setting up MongoDB anywhere means context-switching when you just want to build something.

MongoDB is brilliant, but sometimes I just want to point at a file and start coding. Like SQLite does for SQL.

So I built MangoDB ðŸ¥­. MongoDB's API, backed by your filesystem instead of a server. Code anywhere, deploy to real MongoDB when you're ready.

## How It Works

MongoDB's API, filesystem backend.

```javascript
import { MangoDBClient } from 'mangodb';

const client = new MangoDBClient('./data');
await client.connect();

const db = client.db('myapp');
const users = db.collection('users');

await users.insertOne({ name: 'Alice', email: 'alice@example.com' });
const user = await users.findOne({ name: 'Alice' });
```

No server. No Docker. No connection strings.

When you're ready for production, one line changes:

```javascript
const client = process.env.MONGODB_URI
  ? new MongoClient(process.env.MONGODB_URI)
  : new MangoDBClient('./data');
```

Your code stays identical.

[Check out the code on GitHub](https://github.com/JKershaw/mangodb)

## When to Use It (and When Not To)

**Good for:**
- Prototyping without infrastructure
- Testing (no database setup in CI, tests run in parallel, cleanup is deleting a directory)
- Weird environments (phone development, restricted networks, air-gapped machines)
- Onboarding (new developers clone and run tests immediately)

**Not for:**
- Production (use real MongoDB)
- Performance testing (file I/O has different characteristics)
- Learning MongoDB internals (this mimics the API, not the implementation)

Check the [GitHub repo](https://github.com/JKershaw/mangodb) for current status.

## Building It

I built MangoDB test-driven. Every test runs against both real MongoDB and MangoDB:

```javascript
describe('insertOne', () => {
  it('should insert a document', async () => {
    const result = await collection.insertOne({ name: 'Alice' });
    expect(result.insertedId).to.exist;

    const found = await collection.findOne({ name: 'Alice' });
    expect(found.name).to.equal('Alice');
  });
});
```

Run with `MONGODB_URI` set and you test against real MongoDB. Run without and you test against MangoDB. If behavior differs, I document it in COMPATIBILITY.md.

This caught a lot of assumptions. MongoDB has subtle behaviors everywhere: ObjectIds encode timestamp and process info in specific formats, query operators like `$in` and `$nin` with empty arrays behave asymmetrically, error message formats matter because some libraries parse them. Every time I thought "surely that's close enough," some library would break.

The tests are the compatibility contract. Want to know if MangoDB works for your use case? Check if there are tests for it.

## Try It

```bash
npm install mangodb
```

Point it at a directory, write your code, swap to real MongoDB when you need it.

It's early, so expect rough edges. But it might save you some setup time.

PRs welcome. The test suite runs against real MongoDB, so compatibility issues are usually obvious.

---

*MangoDB is open source on [GitHub](https://github.com/JKershaw/mangodb). Use it for prototyping and testing. Use real MongoDB for production.*
